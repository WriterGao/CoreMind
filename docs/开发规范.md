# CoreMind 开发规范

## 目录

1. [项目结构规范](#项目结构规范)
2. [代码风格规范](#代码风格规范)
3. [命名规范](#命名规范)
4. [API设计规范](#api设计规范)
5. [数据库设计规范](#数据库设计规范)
6. [前端开发规范](#前端开发规范)
7. [错误处理规范](#错误处理规范)
8. [测试规范](#测试规范)
9. [Git工作流规范](#git工作流规范)
10. [文档规范](#文档规范)
11. [安全规范](#安全规范)
12. [性能优化规范](#性能优化规范)

---

## 项目结构规范

### 后端结构

```
backend/
├── app/
│   ├── api/              # API路由层
│   │   ├── __init__.py   # 路由注册
│   │   ├── auth.py       # 认证相关API
│   │   ├── chat_v2.py    # 对话API V2
│   │   └── ...           # 其他API模块
│   ├── core/             # 核心配置和工具
│   │   ├── config.py     # 应用配置
│   │   ├── database.py   # 数据库连接
│   │   ├── security.py   # 安全相关
│   │   └── logging.py    # 日志配置
│   ├── models/           # 数据库模型
│   │   ├── __init__.py   # 模型导出
│   │   ├── user.py       # 用户模型
│   │   └── ...           # 其他模型
│   ├── services/         # 业务逻辑层
│   │   ├── llm_service.py
│   │   ├── assistant/    # 助手相关服务
│   │   ├── knowledge/    # 知识库服务
│   │   └── ...           # 其他服务
│   └── utils/            # 工具函数
│       └── file_parser.py
├── scripts/              # 脚本文件
│   ├── init_db.py        # 数据库初始化
│   └── *.sql             # SQL迁移脚本
├── main.py               # 应用入口
├── requirements.txt      # Python依赖
└── Dockerfile            # Docker配置
```

**规范要求：**
- 每个模块必须有 `__init__.py` 文件
- API层只负责路由和参数验证，业务逻辑放在 `services/`
- 模型层只定义数据结构，不包含业务逻辑
- 服务层实现可复用的业务逻辑

### 前端结构

```
frontend/
├── src/
│   ├── pages/            # 页面组件
│   │   ├── Login.tsx
│   │   ├── Chat.tsx
│   │   └── ...
│   ├── layouts/          # 布局组件
│   │   └── MainLayout.tsx
│   ├── components/       # 通用组件（待创建）
│   ├── services/         # API服务
│   │   └── api.ts
│   ├── store/            # 状态管理
│   │   └── authStore.ts
│   ├── utils/            # 工具函数（待创建）
│   ├── types/            # TypeScript类型定义（待创建）
│   ├── App.tsx           # 根组件
│   └── main.tsx          # 入口文件
├── package.json
├── tsconfig.json
└── vite.config.ts
```

**规范要求：**
- 页面组件放在 `pages/` 目录
- 可复用组件放在 `components/` 目录
- API调用统一在 `services/` 目录
- 类型定义放在 `types/` 目录

---

## 代码风格规范

### Python代码风格

#### 1. 代码格式化

使用 **Black** 进行代码格式化：

```bash
# 格式化代码
black backend/app/

# 检查代码格式
black --check backend/app/
```

**Black配置**（`.black` 或 `pyproject.toml`）：
```toml
[tool.black]
line-length = 100
target-version = ['py311']
include = '\.pyi?$'
```

#### 2. 导入排序

使用 **isort** 进行导入排序：

```bash
# 排序导入
isort backend/app/

# 检查导入顺序
isort --check-only backend/app/
```

**导入顺序规范：**
```python
# 1. 标准库
import sys
from pathlib import Path
from typing import List, Dict, Optional

# 2. 第三方库
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy import Column, String

# 3. 本地应用/库
from app.core.database import get_db
from app.models import User
```

#### 3. 代码检查

使用 **flake8** 进行代码检查：

```bash
# 检查代码
flake8 backend/app/ --max-line-length=100 --exclude=__pycache__,migrations
```

**flake8配置**（`.flake8`）：
```ini
[flake8]
max-line-length = 100
exclude = __pycache__,migrations,venv
ignore = E203, E266, E501, W503
```

#### 4. 类型检查

使用 **mypy** 进行类型检查：

```bash
# 类型检查
mypy backend/app/
```

**mypy配置**（`mypy.ini` 或 `pyproject.toml`）：
```ini
[mypy]
python_version = 3.11
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = False
```

#### 5. 代码示例

```python
"""
模块文档字符串
描述模块的功能和用途
"""
from typing import List, Optional, Dict, Any
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from pydantic import BaseModel

from app.core.database import get_db
from app.core.security import get_current_user
from app.models import User
from app.core.logging import setup_logging

logger = setup_logging()
router = APIRouter()


class RequestModel(BaseModel):
    """请求模型"""
    name: str
    description: Optional[str] = None


class ResponseModel(BaseModel):
    """响应模型"""
    id: str
    name: str
    description: Optional[str] = None
    
    class Config:
        from_attributes = True


@router.get("/items", response_model=List[ResponseModel])
async def list_items(
    current_user: dict = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
) -> List[ResponseModel]:
    """
    获取项目列表
    
    Args:
        current_user: 当前用户信息
        db: 数据库会话
        
    Returns:
        项目列表
        
    Raises:
        HTTPException: 当发生错误时
    """
    try:
        # 业务逻辑
        items = await db.execute(select(User))
        return items.scalars().all()
    except Exception as e:
        logger.error(f"获取项目列表失败: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="获取项目列表失败"
        )
```

### TypeScript代码风格

#### 1. 代码格式化

使用 **Prettier** 进行代码格式化（推荐配置）：

```json
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100,
  "arrowParens": "avoid"
}
```

#### 2. 代码检查

使用 **ESLint** 进行代码检查：

```bash
# 检查代码
npm run lint

# 自动修复
npm run lint -- --fix
```

#### 3. 代码示例

```typescript
import { useEffect, useState, useRef } from 'react'
import { Button, Form, Input, message } from 'antd'
import { PlusOutlined } from '@ant-design/icons'
import { api } from '@/services/api'

interface Item {
  id: string
  name: string
  description?: string
}

interface ItemFormData {
  name: string
  description?: string
}

export default function ItemList() {
  const [items, setItems] = useState<Item[]>([])
  const [loading, setLoading] = useState(false)
  const [form] = Form.useForm()

  useEffect(() => {
    loadItems()
  }, [])

  const loadItems = async () => {
    try {
      setLoading(true)
      const data = await api.get<Item[]>('/items')
      setItems(data)
    } catch (error) {
      message.error('加载失败')
      console.error('加载项目失败:', error)
    } finally {
      setLoading(false)
    }
  }

  const handleSubmit = async (values: ItemFormData) => {
    try {
      await api.post('/items', values)
      message.success('创建成功')
      form.resetFields()
      await loadItems()
    } catch (error: any) {
      message.error(error.response?.data?.detail || '创建失败')
    }
  }

  return (
    <div>
      <Form form={form} onFinish={handleSubmit}>
        {/* 表单内容 */}
      </Form>
    </div>
  )
}
```

---

## 命名规范

### Python命名规范

#### 1. 文件和目录

- **文件名**：使用小写字母和下划线，如 `user_model.py`、`llm_service.py`
- **目录名**：使用小写字母和下划线，如 `api/`、`core/`
- **类名**：使用大驼峰（PascalCase），如 `User`、`LLMService`
- **模块名**：使用小写字母和下划线，如 `user.py`、`llm_config.py`

#### 2. 变量和函数

- **变量名**：使用小写字母和下划线，如 `user_id`、`api_key`
- **函数名**：使用小写字母和下划线，如 `get_user()`、`create_item()`
- **常量**：使用大写字母和下划线，如 `MAX_RETRY_COUNT`、`DEFAULT_TIMEOUT`
- **私有变量/函数**：使用单下划线前缀，如 `_internal_method()`

#### 3. 数据库相关

- **表名**：使用复数形式，小写字母和下划线，如 `users`、`llm_configs`
- **列名**：使用小写字母和下划线，如 `user_id`、`created_at`
- **外键**：使用 `表名_id` 格式，如 `user_id`、`assistant_id`

#### 4. API相关

- **路由路径**：使用小写字母和连字符，如 `/api/v1/llm-configs`
- **端点函数**：使用动词+名词，如 `create_conversation()`、`get_user_info()`

### TypeScript命名规范

#### 1. 文件和组件

- **文件名**：使用大驼峰（PascalCase），如 `Chat.tsx`、`LLMConfig.tsx`
- **组件名**：使用大驼峰，与文件名一致
- **目录名**：使用小写字母，如 `pages/`、`components/`

#### 2. 变量和函数

- **变量名**：使用小驼峰（camelCase），如 `userName`、`apiKey`
- **函数名**：使用小驼峰，如 `loadItems()`、`handleSubmit()`
- **常量**：使用大写字母和下划线，如 `MAX_RETRY_COUNT`、`API_BASE_URL`
- **私有变量/函数**：使用单下划线前缀，如 `_internalMethod()`

#### 3. 类型和接口

- **接口名**：使用大驼峰，如 `User`、`LLMConfig`
- **类型别名**：使用大驼峰，如 `UserResponse`、`ApiResponse<T>`

---

## API设计规范

### RESTful API设计

#### 1. URL设计

```
GET    /api/v1/resource          # 获取资源列表
GET    /api/v1/resource/{id}     # 获取单个资源
POST   /api/v1/resource          # 创建资源
PUT    /api/v1/resource/{id}     # 更新资源（完整更新）
PATCH  /api/v1/resource/{id}     # 更新资源（部分更新）
DELETE /api/v1/resource/{id}     # 删除资源
```

**示例：**
```
GET    /api/v1/llm-configs
GET    /api/v1/llm-configs/{id}
POST   /api/v1/llm-configs
PUT    /api/v1/llm-configs/{id}
DELETE /api/v1/llm-configs/{id}
```

#### 2. 请求和响应格式

**请求格式：**
```python
class CreateRequest(BaseModel):
    """创建请求模型"""
    name: str = Field(..., min_length=1, max_length=100, description="名称")
    description: Optional[str] = Field(None, max_length=500, description="描述")
    config: Dict[str, Any] = Field(..., description="配置信息")
```

**响应格式：**
```python
class ResponseModel(BaseModel):
    """响应模型"""
    id: str = Field(..., description="ID")
    name: str = Field(..., description="名称")
    description: Optional[str] = Field(None, description="描述")
    created_at: str = Field(..., description="创建时间")
    
    class Config:
        from_attributes = True
```

#### 3. 状态码使用

- `200 OK`：成功获取或更新资源
- `201 Created`：成功创建资源
- `204 No Content`：成功删除资源（不返回内容）
- `400 Bad Request`：请求参数错误
- `401 Unauthorized`：未认证
- `403 Forbidden`：无权限
- `404 Not Found`：资源不存在
- `422 Unprocessable Entity`：参数验证失败
- `500 Internal Server Error`：服务器内部错误

#### 4. 错误响应格式

```python
{
    "detail": "错误描述信息",
    "error_code": "ERROR_CODE",  # 可选
    "field": "field_name"        # 可选，字段级错误
}
```

#### 5. 分页和过滤

```python
@router.get("/items")
async def list_items(
    skip: int = Query(0, ge=0, description="跳过数量"),
    limit: int = Query(20, ge=1, le=100, description="每页数量"),
    search: Optional[str] = Query(None, description="搜索关键词")
) -> Dict[str, Any]:
    """获取项目列表（支持分页和搜索）"""
    return {
        "items": [...],
        "total": 100,
        "skip": skip,
        "limit": limit
    }
```

#### 6. API版本管理

- 使用URL路径版本：`/api/v1/`、`/api/v2/`
- 向后兼容：保留旧版本API至少一个版本周期
- 新功能使用新版本：重大变更时升级版本号

---

## 数据库设计规范

### 1. 表设计

#### 命名规范
- 表名：使用复数形式，小写字母和下划线，如 `users`、`llm_configs`
- 列名：使用小写字母和下划线，如 `user_id`、`created_at`
- 索引名：`idx_表名_列名`，如 `idx_users_email`
- 外键名：`fk_表名_列名`，如 `fk_conversations_user_id`

#### 字段设计
```python
class User(Base):
    """用户表"""
    __tablename__ = "users"
    
    id = Column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
        comment="用户ID"
    )
    username = Column(
        String(50),
        unique=True,
        nullable=False,
        index=True,
        comment="用户名"
    )
    created_at = Column(
        DateTime,
        default=datetime.utcnow,
        nullable=False,
        comment="创建时间"
    )
    updated_at = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
        comment="更新时间"
    )
```

#### 必需字段
- `id`：主键，使用UUID
- `created_at`：创建时间
- `updated_at`：更新时间（可选）
- `is_active`：是否启用（业务表）

### 2. 关系设计

#### 外键约束
```python
user_id = Column(
    UUID(as_uuid=True),
    ForeignKey("users.id", ondelete="CASCADE"),
    nullable=False,
    index=True,
    comment="用户ID"
)
```

**ondelete选项：**
- `CASCADE`：级联删除
- `SET NULL`：设置为NULL
- `RESTRICT`：禁止删除

### 3. 索引设计

```python
# 单列索引
username = Column(String(50), index=True)

# 复合索引
Index('idx_user_created', 'user_id', 'created_at')

# 唯一索引
email = Column(String(100), unique=True, index=True)
```

### 4. 迁移脚本

**命名规范：** `YYYYMMDD_HHMMSS_description.sql`

**示例：**
```sql
-- 迁移脚本：20251112_001000_add_assistant_to_conversation.sql
-- 描述：为conversations表添加assistant_id字段

ALTER TABLE conversations 
ADD COLUMN assistant_id UUID;

ALTER TABLE conversations 
ADD CONSTRAINT fk_conversations_assistant_id 
FOREIGN KEY (assistant_id) 
REFERENCES assistant_configs(id) 
ON DELETE SET NULL;

CREATE INDEX idx_conversations_assistant_id 
ON conversations(assistant_id);

COMMENT ON COLUMN conversations.assistant_id IS '关联的助手配置ID';
```

---

## 前端开发规范

### 1. 组件设计

#### 函数组件
```typescript
import { useState, useEffect } from 'react'
import { Button, Table, message } from 'antd'

interface Props {
  userId: string
  onSuccess?: () => void
}

export default function UserList({ userId, onSuccess }: Props) {
  const [users, setUsers] = useState<User[]>([])
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    loadUsers()
  }, [userId])

  const loadUsers = async () => {
    // 加载逻辑
  }

  return (
    <div>
      {/* 组件内容 */}
    </div>
  )
}
```

#### 组件拆分原则
- **单一职责**：每个组件只负责一个功能
- **可复用性**：通用组件放在 `components/` 目录
- **组合优于继承**：使用组合方式构建复杂组件

### 2. 状态管理

#### 使用Zustand
```typescript
import { create } from 'zustand'

interface AuthState {
  token: string | null
  user: User | null
  login: (token: string, user: User) => void
  logout: () => void
}

export const useAuthStore = create<AuthState>((set) => ({
  token: null,
  user: null,
  login: (token, user) => set({ token, user }),
  logout: () => set({ token: null, user: null }),
}))
```

#### 状态管理原则
- **全局状态**：用户信息、认证状态等
- **局部状态**：表单数据、UI状态等使用 `useState`
- **避免过度使用全局状态**

### 3. API调用

#### 统一API服务
```typescript
// services/api.ts
import axios from 'axios'

const api = axios.create({
  baseURL: '/api/v1',
  timeout: 30000,
})

// 请求拦截器
api.interceptors.request.use((config) => {
  const token = useAuthStore.getState().token
  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
})

// 响应拦截器
api.interceptors.response.use(
  (response) => response.data,
  (error) => {
    if (error.response?.status === 401) {
      useAuthStore.getState().logout()
      window.location.href = '/login'
    }
    return Promise.reject(error)
  }
)

export default api
```

#### API模块化
```typescript
// services/api.ts
export const userAPI = {
  list: () => api.get<User[]>('/users'),
  get: (id: string) => api.get<User>(`/users/${id}`),
  create: (data: CreateUserData) => api.post<User>('/users', data),
  update: (id: string, data: UpdateUserData) => api.put<User>(`/users/${id}`, data),
  delete: (id: string) => api.delete(`/users/${id}`),
}
```

### 4. 错误处理

```typescript
const handleSubmit = async (values: FormData) => {
  try {
    setLoading(true)
    await api.post('/items', values)
    message.success('操作成功')
    onSuccess?.()
  } catch (error: any) {
    const errorMessage = error.response?.data?.detail || '操作失败'
    message.error(errorMessage)
    console.error('操作失败:', error)
  } finally {
    setLoading(false)
  }
}
```

### 5. 类型定义

```typescript
// types/user.ts
export interface User {
  id: string
  username: string
  email: string
  full_name?: string
  is_active: boolean
  created_at: string
}

export interface CreateUserData {
  username: string
  email: string
  password: string
  full_name?: string
}

export interface UpdateUserData {
  email?: string
  full_name?: string
  is_active?: boolean
}
```

---

## 错误处理规范

### 后端错误处理

#### 1. 异常处理
```python
from fastapi import HTTPException, status
from app.core.logging import setup_logging

logger = setup_logging()

@router.post("/items")
async def create_item(
    item_data: CreateItemRequest,
    current_user: dict = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    try:
        # 业务逻辑
        item = Item(**item_data.dict())
        db.add(item)
        await db.commit()
        return item
    except ValueError as e:
        logger.warning(f"参数错误: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"创建项目失败: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="创建项目失败，请稍后重试"
        )
```

#### 2. 自定义异常
```python
# app/core/exceptions.py
class CoreMindException(Exception):
    """基础异常类"""
    def __init__(self, message: str, error_code: str = None):
        self.message = message
        self.error_code = error_code
        super().__init__(self.message)


class ValidationError(CoreMindException):
    """验证错误"""
    pass


class NotFoundError(CoreMindException):
    """资源不存在"""
    pass
```

#### 3. 全局异常处理
```python
# main.py
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    return JSONResponse(
        status_code=422,
        content={"detail": exc.errors()}
    )
```

### 前端错误处理

#### 1. API错误处理
```typescript
try {
  const response = await api.post('/items', data)
  message.success('创建成功')
} catch (error: any) {
  if (error.response) {
    // 服务器返回错误
    const status = error.response.status
    const detail = error.response.data?.detail || '操作失败'
    
    if (status === 401) {
      message.error('未授权，请重新登录')
      // 跳转到登录页
    } else if (status === 403) {
      message.error('无权限执行此操作')
    } else if (status === 404) {
      message.error('资源不存在')
    } else {
      message.error(detail)
    }
  } else if (error.request) {
    // 请求发送但无响应
    message.error('网络错误，请检查网络连接')
  } else {
    // 其他错误
    message.error('操作失败，请稍后重试')
  }
  console.error('API错误:', error)
}
```

---

## 测试规范

### 后端测试

#### 1. 测试文件结构
```
backend/
├── tests/
│   ├── __init__.py
│   ├── conftest.py          # pytest配置
│   ├── test_api/
│   │   ├── test_auth.py
│   │   └── test_chat.py
│   ├── test_services/
│   │   └── test_llm_service.py
│   └── test_models/
│       └── test_user.py
```

#### 2. 测试示例
```python
# tests/test_api/test_auth.py
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.mark.asyncio
async def test_register_user():
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post(
            "/api/v1/auth/register",
            json={
                "username": "testuser",
                "email": "test@example.com",
                "password": "testpass123"
            }
        )
        assert response.status_code == 200
        assert "id" in response.json()
```

#### 3. 运行测试
```bash
# 运行所有测试
pytest

# 运行特定测试文件
pytest tests/test_api/test_auth.py

# 运行并生成覆盖率报告
pytest --cov=app --cov-report=html
```

### 前端测试

#### 1. 测试工具
- **单元测试**：Vitest
- **组件测试**：React Testing Library
- **E2E测试**：Playwright（可选）

#### 2. 测试示例
```typescript
// tests/Chat.test.tsx
import { render, screen, fireEvent } from '@testing-library/react'
import Chat from '@/pages/Chat'

describe('Chat Component', () => {
  it('should render chat interface', () => {
    render(<Chat />)
    expect(screen.getByPlaceholderText(/输入消息/)).toBeInTheDocument()
  })

  it('should send message on submit', async () => {
    // 测试逻辑
  })
})
```

---

## Git工作流规范

### 1. 分支管理

#### 分支命名
- `main`：主分支，生产环境代码
- `develop`：开发分支
- `feature/功能名称`：功能分支，如 `feature/llm-config`
- `bugfix/问题描述`：Bug修复分支，如 `bugfix/login-error`
- `hotfix/问题描述`：紧急修复分支

#### 分支策略
```
main (生产)
  ↑
  | (合并)
develop (开发)
  ↑
  | (合并)
feature/xxx (功能开发)
```

### 2. 提交信息规范

#### 提交格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

#### Type类型
- `feat`：新功能
- `fix`：Bug修复
- `docs`：文档更新
- `style`：代码格式（不影响功能）
- `refactor`：重构
- `test`：测试相关
- `chore`：构建/工具相关

#### 示例
```
feat(api): 添加LLM配置管理API

- 实现LLM配置的CRUD操作
- 支持多种LLM提供商
- 添加API密钥加密存储

Closes #123
```

### 3. 代码审查

#### Pull Request规范
- **标题**：清晰描述变更内容
- **描述**：说明变更原因、影响范围
- **关联Issue**：使用 `Closes #123` 关联Issue
- **测试**：确保所有测试通过
- **文档**：更新相关文档

#### 审查清单
- [ ] 代码符合风格规范
- [ ] 通过所有测试
- [ ] 无安全漏洞
- [ ] 性能影响评估
- [ ] 文档已更新

---

## 文档规范

### 1. 代码注释

#### Python文档字符串
```python
def create_conversation(
    conv_data: ConversationCreateV2,
    current_user: dict = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
) -> ConversationResponse:
    """
    创建对话
    
    根据用户选择的助手配置创建新的对话会话。
    
    Args:
        conv_data: 对话创建数据，包含标题和助手ID
        current_user: 当前用户信息（通过依赖注入获取）
        db: 数据库会话（通过依赖注入获取）
        
    Returns:
        ConversationResponse: 创建的对话信息
        
    Raises:
        HTTPException: 
            - 404: 助手配置不存在
            - 404: LLM配置不存在或已删除
            
    Example:
        >>> data = ConversationCreateV2(
        ...     title="新对话",
        ...     assistant_id="uuid-here"
        ... )
        >>> conversation = await create_conversation(data, user, db)
        >>> print(conversation.id)
    """
    pass
```

#### TypeScript注释
```typescript
/**
 * 加载对话列表
 * 
 * @returns Promise<void>
 * @throws {Error} 当API调用失败时
 */
const loadConversations = async (): Promise<void> => {
  try {
    const data = await chatV2API.listConversations()
    setConversations(data)
  } catch (error) {
    message.error('加载对话列表失败')
    throw error
  }
}
```

### 2. API文档

#### 使用FastAPI自动文档
- 访问 `/docs` 查看Swagger文档
- 访问 `/redoc` 查看ReDoc文档
- 确保所有API都有清晰的描述和示例

### 3. 项目文档

#### README.md
- 项目简介
- 快速开始
- 环境要求
- 安装步骤
- 使用示例

#### 其他文档
- `docs/系统设计文档.md`：系统架构设计
- `docs/API文档.md`：API详细说明
- `docs/部署指南.md`：部署步骤
- `docs/开发规范.md`：本文档

---

## 安全规范

### 1. 认证和授权

#### JWT Token
- Token过期时间：30分钟
- 刷新Token机制（待实现）
- Token存储在HttpOnly Cookie（推荐）或localStorage

#### 权限控制
```python
# 检查用户权限
async def check_permission(
    resource_id: str,
    current_user: dict = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    # 验证用户是否有权限访问资源
    result = await db.execute(
        select(Resource).where(
            Resource.id == resource_id,
            Resource.user_id == current_user["user_id"]
        )
    )
    if not result.scalar_one_or_none():
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="无权限访问此资源"
        )
```

### 2. 数据安全

#### 敏感信息加密
- API密钥：加密存储
- 密码：使用bcrypt哈希
- 数据库连接信息：使用环境变量

#### SQL注入防护
- 使用SQLAlchemy ORM，避免原生SQL
- 参数化查询
- 输入验证和清理

### 3. 输入验证

#### Pydantic验证
```python
class CreateUserRequest(BaseModel):
    username: str = Field(
        ...,
        min_length=3,
        max_length=50,
        regex="^[a-zA-Z0-9_]+$",
        description="用户名，3-50个字符，只能包含字母、数字和下划线"
    )
    email: EmailStr = Field(..., description="邮箱地址")
    password: str = Field(
        ...,
        min_length=8,
        max_length=72,
        description="密码，至少8个字符"
    )
```

### 4. CORS配置

```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.BACKEND_CORS_ORIGINS,  # 生产环境限制具体域名
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)
```

---

## 性能优化规范

### 1. 数据库优化

#### 查询优化
```python
# 使用索引
user_id = Column(UUID, index=True)

# 避免N+1查询
users = await db.execute(
    select(User).options(joinedload(User.profile))
)

# 使用分页
items = await db.execute(
    select(Item)
    .where(Item.user_id == user_id)
    .offset(skip)
    .limit(limit)
)
```

#### 连接池配置
```python
engine = create_async_engine(
    DATABASE_URL,
    pool_size=20,
    max_overflow=10,
    pool_pre_ping=True,
)
```

### 2. 缓存策略

#### Redis缓存
```python
from app.core.redis import redis_client

async def get_user_cached(user_id: str):
    cache_key = f"user:{user_id}"
    cached = await redis_client.get(cache_key)
    if cached:
        return json.loads(cached)
    
    user = await db.get(User, user_id)
    await redis_client.setex(
        cache_key,
        3600,  # 1小时过期
        json.dumps(user.dict())
    )
    return user
```

### 3. 前端优化

#### 代码分割
```typescript
// 路由懒加载
const Chat = lazy(() => import('@/pages/Chat'))
const LLMConfig = lazy(() => import('@/pages/LLMConfig'))
```

#### 防抖和节流
```typescript
import { debounce } from 'lodash'

const handleSearch = debounce((value: string) => {
  // 搜索逻辑
}, 300)
```

---

## 开发工具配置

### 1. 编辑器配置

#### VS Code配置（.vscode/settings.json）
```json
{
  "python.formatting.provider": "black",
  "python.linting.enabled": true,
  "python.linting.flake8Enabled": true,
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.organizeImports": true
  },
  "[python]": {
    "editor.defaultFormatter": "ms-python.black-formatter"
  },
  "[typescript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  }
}
```

### 2. Git Hooks

#### pre-commit钩子
```bash
#!/bin/sh
# .git/hooks/pre-commit

# Python代码检查
black --check backend/app/
isort --check-only backend/app/
flake8 backend/app/

# TypeScript代码检查
cd frontend && npm run lint
```

### 3. CI/CD配置

#### GitHub Actions示例
```yaml
name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: |
          cd backend
          pip install -r requirements.txt
      - name: Run tests
        run: |
          cd backend
          pytest
      - name: Lint
        run: |
          cd backend
          black --check app/
          flake8 app/
```

---

## 总结

### 核心原则

1. **一致性**：保持代码风格和结构的一致性
2. **可读性**：代码应该易于理解和维护
3. **可测试性**：代码应该易于测试
4. **安全性**：始终考虑安全性
5. **性能**：关注性能优化
6. **文档**：保持文档更新

### 检查清单

在提交代码前，确保：

- [ ] 代码符合风格规范（Black、isort、ESLint）
- [ ] 所有测试通过
- [ ] 代码有适当的注释和文档
- [ ] 无安全漏洞
- [ ] 性能影响已评估
- [ ] 相关文档已更新
- [ ] Git提交信息规范

---

**最后更新：** 2025-11-12  
**维护者：** CoreMind开发团队

